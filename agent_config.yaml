# Agent Configuration
# This file controls the hierarchical task decomposition and failure handling behavior

# ==============================
# LLM Settings
# ==============================
llm:
  # Model to use (can be overridden by OLLAMA_MODEL env var)
  model: "qwen3:14b"

  # Temperature for inference (0.0 = deterministic, 1.0 = creative)
  temperature: 0.2

  # System prompt for the agent
  system_prompt: |
    You are a local coding agent that helps build software projects.

    Your workflow:
    1. If NO TASKS YET: Use decompose_task to break down the goal into a simple task structure
    2. Work on your current subtask using the available tools (write_file, read_file, run_bash, etc.)
    3. When you complete a subtask, call mark_subtask_complete(success=True)
    4. If you cannot complete it, call mark_subtask_complete(success=False, reason="...")
    5. The system will automatically advance you to the next subtask

    Guidelines:
    - ALWAYS use tools - never just respond with text
    - For simple goals, create ONE task with ONE subtask, then immediately work on it
    - You can work with any programming language or technology stack (Python, JavaScript, HTML/CSS, TypeScript, etc.)
    - For Python projects: use pytest for testing and ruff for linting
    - For web projects: create HTML, CSS, and JavaScript files as needed
    - For other languages: use appropriate tools and conventions for that ecosystem
    - When you finish your current subtask, ALWAYS call mark_subtask_complete
    - Be concise and focused on the current subtask
    - Adapt your approach based on the project type and requirements

    Available tools:
    - write_file(path, content, append=False, encoding="utf-8", line_end=None, overwrite=True): Write/overwrite files
    - read_file(path, encoding="utf-8", max_size=1000000): Read files (up to 1MB by default)
    - list_dir(path): List directory contents
    - run_bash(command, timeout=60): Run ANY shell command with full bash features
    - mark_subtask_complete(success, reason): Mark current subtask done
    - decompose_task(...): Break down goal into tasks (only if NO TASKS YET)

    Common operations:
    - write_file("file.py", "import sys\n\nprint('hello')")  # Write file
    - write_file("file.py", "\n# more code", append=True)  # Append to file
    - write_file("file.bat", "echo hello", line_end="\r\n")  # Windows line endings
    - read_file("file.py")  # Read entire file
    - run_bash("pytest tests/ -v")  # Run tests
    - run_bash("ruff check .")  # Lint code
    - run_bash("grep -r 'pattern' *.py")  # Search code
    - run_bash("find . -name '*.py' | wc -l")  # Find files

# ==============================
# Round Limits
# ==============================
rounds:
  # Maximum rounds per subtask before forced escalation
  max_per_subtask: 12

  # Global maximum rounds for the entire agent run
  max_global: 256

# ==============================
# Hierarchy Limits
# ==============================
hierarchy:
  # Maximum depth of subtask nesting (1 = top-level, 5 = 5 levels deep)
  max_depth: 5

  # Maximum number of sibling subtasks at any level
  max_siblings: 8

# ==============================
# Escalation Strategy
# ==============================
escalation:
  # When a subtask hits max_rounds_per_subtask, what should happen?
  # Options: "force_decompose", "agent_decides"
  # - force_decompose: Always decompose into smaller subtasks (no give-up option)
  # - agent_decides: Let agent choose between decompose/zoom_out/give_up (original behavior)
  strategy: "force_decompose"

  # When at max depth and still failing, zoom out to this level
  # Options: "parent", "task", "root", "smart"
  # - parent: Go up one level to parent subtask
  # - task: Go to task level (top of current task)
  # - root: Go to root goal and reconsider entire approach
  # - smart: Analyze subtask tree to find the actual root of the problem
  zoom_out_target: "smart"

  # Number of times to reconsider approach at root before final failure
  max_approach_retries: 3

  # When zooming out, should we mark failed path as blocked?
  block_failed_paths: true

# ==============================
# Loop Detection
# ==============================
loop_detection:
  # Same action attempted N times = loop
  max_action_repeats: 3

  # Same subtask failed N times = escalate
  max_subtask_repeats: 2

  # Context age in seconds before considered stale
  max_context_age: 300

# ==============================
# Decomposition Behavior
# ==============================
decomposition:
  # When forcing decomposition, what's the minimum number of child subtasks?
  min_children: 2

  # Maximum number of child subtasks when decomposing
  max_children: 6

  # LLM temperature for decomposition planning (higher = more creative)
  temperature: 0.2

  # Should decomposition be granular (prefer more, smaller subtasks)?
  prefer_granular: true

# ==============================
# Approach Reconsideration
# ==============================
approach_retry:
  # Track approach attempts per task
  enabled: true

  # When reconsidering approach, should we reset all subtasks?
  reset_subtasks_on_retry: true

  # Should we preserve successful subtasks when retrying?
  preserve_completed: true

  # Prompt style for approach reconsideration
  # Options: "fresh_start", "learn_from_failures"
  retry_style: "learn_from_failures"

# ==============================
# Context Management
# ==============================
context:
  # Number of message exchanges to keep in history
  # Each exchange = 2 messages (assistant + tool response)
  # Should match or exceed max_per_subtask to avoid forgetting early rounds
  # Default: same as max_per_subtask (12)
  history_keep: 12

  # Maximum tokens to allow in context (approximate)
  # Set to 0 to disable token limiting
  max_tokens: 8000

  # How many recent actions to include in context
  recent_actions_limit: 10

  # Enable context compression (summarize old messages)
  enable_compression: false  # Not yet implemented

  # Compression trigger: compress when context exceeds this many messages
  compression_threshold: 20
