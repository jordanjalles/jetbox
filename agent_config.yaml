# Agent Configuration
# This file controls the hierarchical task decomposition and failure handling behavior

# ==============================
# Global Behavior Parameter Defaults
# ==============================
# These apply to all agents unless explicitly overridden in agent-specific configs
behavior_defaults:
  CompactWhenNearFullBehavior:
    max_tokens: 8000          # Model-based: 8K for qwen2.5-coder:3b/7b
    compact_threshold: 0.75   # Compact at 75% capacity
    keep_recent: 20           # Keep last 20 message exchanges

  LoopDetectionBehavior:
    max_repeats: 5            # Warn after 5 identical actions

  CommandToolsBehavior:
    whitelist:                # Safe commands for coding tasks
      - python
      - pytest
      - ruff
      - pip

  HierarchicalContextBehavior:
    max_depth: 5              # Maximum task nesting
    max_siblings: 8           # Max subtasks per level
    keep_recent: 12           # Message exchanges to keep

  SubAgentContextBehavior:
    # No parameters needed - uses global settings

  FileToolsBehavior:
    # No parameters needed

  ServerToolsBehavior:
    # No parameters needed

  ArchitectToolsBehavior:
    # No parameters needed

  WorkspaceTaskNotesBehavior:
    # No parameters needed

  DelegationBehavior:
    # Parameters come from agents.yaml relationships

# ==============================
# LLM Settings
# ==============================
llm:
  # Model to use (can be overridden by OLLAMA_MODEL env var)
  model: "qwen3:14b"

  # Temperature for inference (0.0 = deterministic, 1.0 = creative)
  temperature: 0.2

  # System prompt for the agent (base prompt - context strategies may extend this)
  system_prompt: |
    You are a local coding agent that helps build software projects.

    Guidelines:
    - ALWAYS use tools - never just respond with text
    - You can work with any programming language or technology stack (Python, JavaScript, HTML/CSS, TypeScript, etc.)
    - For Python projects: use pytest for testing and ruff for linting
    - For web projects: create HTML, CSS, and JavaScript files as needed
    - For other languages: use appropriate tools and conventions for that ecosystem
    - Be concise and focused on completing the goal
    - Adapt your approach based on the project type and requirements

    Core tools available:
    - write_file(path, content, append=False, encoding="utf-8", line_end=None, overwrite=True): Write/overwrite files
    - read_file(path, encoding="utf-8", max_size=1000000): Read files (up to 1MB by default)
    - list_dir(path): List directory contents
    - run_bash(command, timeout=60): Run ANY shell command with full bash features

    Common operations:
    - write_file("file.py", "import sys\n\nprint('hello')")  # Write file
    - write_file("file.py", "\n# more code", append=True)  # Append to file
    - write_file("file.bat", "echo hello", line_end="\r\n")  # Windows line endings
    - read_file("file.py")  # Read entire file
    - run_bash("pytest tests/ -v")  # Run tests
    - run_bash("ruff check .")  # Lint code
    - run_bash("grep -r 'pattern' *.py")  # Search code
    - run_bash("find . -name '*.py' | wc -l")  # Find files

# ==============================
# Round Limits
# ==============================
rounds:
  # Maximum rounds per subtask before forced escalation
  max_per_subtask: 12

  # Global maximum rounds for the entire agent run
  max_global: 256

# ==============================
# Time Limits
# ==============================
timeouts:
  # Maximum wall-clock time (seconds) for entire goal
  # 0 = no limit
  # Can be overridden when creating TaskExecutorAgent
  max_goal_time: 600  # 10 minutes (default)

  # When timeout occurs, create jetbox notes summary and context dump
  create_summary_on_timeout: true

  # Save context dump to .agent_context/timeout_dumps/
  save_context_dump: true

# ==============================
# Hierarchy Limits
# ==============================
hierarchy:
  # Maximum depth of subtask nesting (1 = top-level, 5 = 5 levels deep)
  max_depth: 5

  # Maximum number of sibling subtasks at any level
  max_siblings: 8

# ==============================
# Escalation Strategy
# ==============================
escalation:
  # When a subtask hits max_rounds_per_subtask, what should happen?
  # Options: "force_decompose", "agent_decides"
  # - force_decompose: Always decompose into smaller subtasks (no give-up option)
  # - agent_decides: Let agent choose between decompose/zoom_out/give_up (original behavior)
  strategy: "force_decompose"

  # When at max depth and still failing, zoom out to this level
  # Options: "parent", "task", "root", "smart"
  # - parent: Go up one level to parent subtask
  # - task: Go to task level (top of current task)
  # - root: Go to root goal and reconsider entire approach
  # - smart: Analyze subtask tree to find the actual root of the problem
  zoom_out_target: "smart"

  # Number of times to reconsider approach at root before final failure
  max_approach_retries: 3

  # When zooming out, should we mark failed path as blocked?
  block_failed_paths: true

# ==============================
# Loop Detection
# ==============================
loop_detection:
  # Same action attempted N times = loop
  max_action_repeats: 3

  # Same subtask failed N times = escalate
  max_subtask_repeats: 2

  # Context age in seconds before considered stale
  max_context_age: 300

# ==============================
# Decomposition Behavior
# ==============================
decomposition:
  # When forcing decomposition, what's the minimum number of child subtasks?
  min_children: 2

  # Maximum number of child subtasks when decomposing
  max_children: 6

  # LLM temperature for decomposition planning (higher = more creative)
  temperature: 0.2

  # Should decomposition be granular (prefer more, smaller subtasks)?
  prefer_granular: true

# ==============================
# Approach Reconsideration
# ==============================
approach_retry:
  # Track approach attempts per task
  enabled: true

  # When reconsidering approach, should we reset all subtasks?
  reset_subtasks_on_retry: true

  # Should we preserve successful subtasks when retrying?
  preserve_completed: true

  # Prompt style for approach reconsideration
  # Options: "fresh_start", "learn_from_failures"
  retry_style: "learn_from_failures"

# ==============================
# Context Management
# ==============================
context:
  # Number of message exchanges to keep in history
  # Each exchange = 2 messages (assistant + tool response)
  # Should match or exceed max_per_subtask to avoid forgetting early rounds
  # Default: same as max_per_subtask (12)
  history_keep: 12

  # Maximum tokens to allow in context (approximate)
  # Set to 0 to disable token limiting
  max_tokens: 8000

  # How many recent actions to include in context
  recent_actions_limit: 10

  # Enable context compression (summarize old messages)
  enable_compression: false  # Not yet implemented

  # Compression trigger: compress when context exceeds this many messages
  compression_threshold: 20
