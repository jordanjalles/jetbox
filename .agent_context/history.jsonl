{"name": "write_file", "args": {"content": "\"\"\"Utility functions for working with text files.\n\nThis module provides simple helper functions for common text file\noperations such as counting lines and concatenating multiple files.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom pathlib import Path\nfrom typing import Iterable, List\n\n__all__ = [\"count_lines\", \"concat_files\"]\n\n\n+def _iter_lines(file_path: Path) -> Iterable[str]:\n+    \"\"\"Yield lines from *file_path*.\n+\n+    The helper is used by :func:`count_lines` and :func:`concat_files` to\n+    avoid opening the file twice. It reads the file in text mode using the\n+    default system encoding which is sufficient for most simple use\u2011cases.\n+    \"\"\"\n+    with file_path.open(\"r\", encoding=\"utf-8\") as f:\n+        for line in f:\n+            yield line\n+\n+\n+def count_lines(file_path: str | Path) -> int:\n+    \"\"\"Return the number of lines in *file_path*.\n+\n+    Parameters\n+    ----------\n+    file_path:\n+        Path to the file whose lines should be counted.\n+\n+    Returns\n+    -------\n+    int\n+        The number of lines in the file.\n+    \"\"\"\n+    path = Path(file_path)\n+    if not path.is_file():\n+        raise FileNotFoundError(f\"File not found: {path}\")\n+    return sum(1 for _ in _iter_lines(path))\n+\n+\n+def concat_files(file_paths: Iterable[str | Path], output_path: str | Path) -> None:\n+    \"\"\"Concatenate multiple text files into *output_path*.\n+\n+    Parameters\n+    ----------\n+    file_paths:\n+        Iterable of file paths to read. They are processed in the order\n+        provided.\n+    output_path:\n+        Destination file. Existing files are overwritten.\n+    \"\"\"\n+    out_path = Path(output_path)\n+    # Ensure parent directories exist\n+    out_path.parent.mkdir(parents=True, exist_ok=True)\n+    with out_path.open(\"w\", encoding=\"utf-8\") as out_f:\n+        for fp in file_paths:\n+            path = Path(fp)\n+            if not path.is_file():\n+                raise FileNotFoundError(f\"File not found: {path}\")\n+            for line in _iter_lines(path):\n+                out_f.write(line)\n+\n*** End of file ***\"\n", "create_dirs": true, "path": "text_util.py"}, "timestamp": 1761207885.750798, "result": "success", "error_msg": "", "attempt_count": 1}
{"name": "run_cmd", "args": {"cmd": ["bash", "-lc", "mkdir -p tests"], "timeout_sec": 10}, "timestamp": 1761207887.497185, "result": "success", "error_msg": "", "attempt_count": 1}
{"name": "write_file", "args": {"content": "# Test package initialization\n", "create_dirs": true, "path": "tests/__init__.py"}, "timestamp": 1761207888.747288, "result": "success", "error_msg": "", "attempt_count": 1}
{"name": "write_file", "args": {"content": "import os\nimport tempfile\nimport shutil\nfrom pathlib import Path\n\nimport pytest\n\nfrom text_util import count_lines, concat_files\n\n\ndef test_count_lines(tmp_path: Path):\n    # Create a temporary file with known number of lines\n    file_path = tmp_path / \"sample.txt\"\n    lines = [\"first line\", \"second line\", \"third line\"]\n    file_path.write_text(\"\\n\".join(lines) + \"\\n\", encoding=\"utf-8\")\n\n    assert count_lines(file_path) == len(lines)\n\n\ndef test_concat_files(tmp_path: Path):\n    # Create two source files\n    src1 = tmp_path / \"a.txt\"\n    src2 = tmp_path / \"b.txt\"\n    src1.write_text(\"hello\\nworld\\n\", encoding=\"utf-8\")\n    src2.write_text(\"foo\\nbar\\n\", encoding=\"utf-8\")\n\n    out = tmp_path / \"out.txt\"\n    concat_files([src1, src2], out)\n\n    expected = \"hello\\nworld\\nfoo\\nbar\\n\"\n    assert out.read_text(encoding=\"utf-8\") == expected\n\n\ndef test_concat_files_nonexistent(tmp_path: Path):\n    # Ensure FileNotFoundError is raised for missing file\n    src = tmp_path / \"missing.txt\"\n    out = tmp_path / \"out.txt\"\n    with pytest.raises(FileNotFoundError):\n        concat_files([src], out)\n\n*** End of file ***", "create_dirs": true, "path": "tests/test_text_util.py"}, "timestamp": 1761207892.238844, "result": "success", "error_msg": "", "attempt_count": 1}
{"name": "write_file", "args": {"content": "\"\"\"Utility functions for working with text files.\n\nThis module provides simple helpers for common text file operations.\n\"\"\"\n\nfrom pathlib import Path\nfrom typing import Iterable\n\n\ndef count_lines(file_path: Path | str) -> int:\n    \"\"\"Return the number of lines in *file_path*.\n\n    Parameters\n    ----------\n    file_path:\n        Path to the file to count.\n\n    Returns\n    -------\n    int\n        Number of lines in the file.\n    \"\"\"\n    path = Path(file_path)\n    if not path.is_file():\n        raise FileNotFoundError(f\"File not found: {path}\")\n    # Read in binary to avoid decoding errors, then split on b\"\\n\"\n    with path.open(\"rb\") as f:\n        return sum(1 for _ in f)\n\n\ndef concat_files(source_files: Iterable[Path | str], destination: Path | str) -> None:\n    \"\"\"Concatenate *source_files* into *destination*.\n\n    Parameters\n    ----------\n    source_files:\n        Iterable of paths to source files.\n    destination:\n        Path to the destination file.\n    \"\"\"\n    dest_path = Path(destination)\n    with dest_path.open(\"wb\") as out_f:\n        for src in source_files:\n            src_path = Path(src)\n            if not src_path.is_file():\n                raise FileNotFoundError(f\"Source file not found: {src_path}\")\n            with src_path.open(\"rb\") as in_f:\n                shutil.copyfileobj(in_f, out_f)\n\n# End of file\n", "create_dirs": true, "path": "text_util.py"}, "timestamp": 1761207898.133093, "result": "success", "error_msg": "", "attempt_count": 1}
{"name": "write_file", "args": {"append": true, "content": "import shutil\n", "create_dirs": false, "path": "text_util.py"}, "timestamp": 1761207899.207389, "result": "error", "error_msg": "write_file() got an unexpected keyword argument 'append'", "attempt_count": 1}
{"name": "read_file", "args": {"max_bytes": 2000, "path": "text_util.py"}, "timestamp": 1761207900.185679, "result": "success", "error_msg": "", "attempt_count": 1}
{"name": "write_file", "args": {"content": "\"\"\"Utility functions for working with text files.\n\nThis module provides simple helpers for common text file operations.\n\"\"\"\n\nfrom pathlib import Path\nfrom typing import Iterable\nimport shutil\n\n\ndef count_lines(file_path: Path | str) -> int:\n    \"\"\"Return the number of lines in *file_path*.\n\n    Parameters\n    ----------\n    file_path:\n        Path to the file to count.\n\n    Returns\n    -------\n    int\n        Number of lines in the file.\n    \"\"\"\n    path = Path(file_path)\n    if not path.is_file():\n        raise FileNotFoundError(f\"File not found: {path}\")\n    with path.open(\"rb\") as f:\n        return sum(1 for _ in f)\n\n\ndef concat_files(source_files: Iterable[Path | str], destination: Path | str) -> None:\n    \"\"\"Concatenate *source_files* into *destination*.\n\n    Parameters\n    ----------\n    source_files:\n        Iterable of paths to source files.\n    destination:\n        Path to the destination file.\n    \"\"\"\n    dest_path = Path(destination)\n    with dest_path.open(\"wb\") as out_f:\n        for src in source_files:\n            src_path = Path(src)\n            if not src_path.is_file():\n                raise FileNotFoundError(f\"Source file not found: {src_path}\")\n            with src_path.open(\"rb\") as in_f:\n                shutil.copyfileobj(in_f, out_f)\n\n# End of file\n", "create_dirs": true, "path": "text_util.py"}, "timestamp": 1761207903.738621, "result": "success", "error_msg": "", "attempt_count": 1}
{"name": "run_cmd", "args": {"cmd": ["pytest", "-q"], "timeout_sec": 120}, "timestamp": 1761207915.485243, "result": "success", "error_msg": "", "attempt_count": 1}
{"name": "read_file", "args": {"max_bytes": 2000, "path": "tests/test_text_util.py"}, "timestamp": 1761207916.681179, "result": "success", "error_msg": "", "attempt_count": 1}
{"name": "write_file", "args": {"content": "import os\nimport tempfile\nimport shutil\nfrom pathlib import Path\n\nimport pytest\n\nfrom text_util import count_lines, concat_files\n\n\ndef test_count_lines(tmp_path: Path):\n    # Create a temporary file with known number of lines\n    file_path = tmp_path / \"sample.txt\"\n    lines = [\"first line\", \"second line\", \"third line\"]\n    file_path.write_text(\"\\n\".join(lines) + \"\\n\", encoding=\"utf-8\")\n\n    assert count_lines(file_path) == len(lines)\n\n\ndef test_concat_files(tmp_path: Path):\n    # Create two source files\n    src1 = tmp_path / \"a.txt\"\n    src2 = tmp_path / \"b.txt\"\n    src1.write_text(\"hello\\nworld\\n\", encoding=\"utf-8\")\n    src2.write_text(\"foo\\nbar\\n\", encoding=\"utf-8\")\n\n    out = tmp_path / \"out.txt\"\n    concat_files([src1, src2], out)\n\n    expected = \"hello\\nworld\\nfoo\\nbar\\n\"\n    assert out.read_text(encoding=\"utf-8\") == expected\n\n\ndef test_concat_files_nonexistent(tmp_path: Path):\n    # Ensure FileNotFoundError is raised for missing file\n    src = tmp_path / \"missing.txt\"\n    out = tmp_path / \"out.txt\"\n    with pytest.raises(FileNotFoundError):\n        concat_files([src], out)\n", "create_dirs": false, "path": "tests/test_text_util.py"}, "timestamp": 1761207920.419987, "result": "success", "error_msg": "", "attempt_count": 1}
{"name": "run_cmd", "args": {"cmd": ["pytest", "-q"], "timeout_sec": 120}, "timestamp": 1761207921.914027, "result": "success", "error_msg": "", "attempt_count": 1}
